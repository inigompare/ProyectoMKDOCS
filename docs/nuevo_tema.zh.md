# UNIX: 进程和任务控制 / 个人任务

**作者：** Iñigo Durán Sanz

本指南探讨了 UNIX/Linux 系统中的进程管理，涵盖从后台执行到优先级管理和信号的内容。

---

## 实践练习

### 1. `yes` 命令

`yes` 命令向终端发送 "yes" 的无限输出。

- **观察**：执行时，它会使终端饱和并用连续文本“弄脏”屏幕。

### 2. 使用 CTRL+C 中断

我们可以使用中断组合键停止上一个命令的“攻击性”执行。

![图片 2](img/imagen_2.png)

### 3. 重定向到 `/dev/null`

我们运行 `yes > /dev/null`。

- **结果**：屏幕不再充满文本（输出被丢弃），但终端仍然繁忙，我们无法取回 _提示符 (prompt)_。

### 4. 再次中断

我们使用 `CTRL+C` 取消上一个进程以重新获得控制权。

![图片 4](img/imagen_4.png)

### 5. 后台执行 (`&`)

我们运行 `yes > /dev/null &`。

- **结果**：系统立即返回 _提示符_。
- **数据**：我们获得 **任务编号 (Job Number)** 和 **PID** (进程 ID)。

![图片 5](img/imagen_5.png)

### 6. 任务状态

我们使用 `jobs` 命令来验证进程是否仍在后台运行。

![图片 6](img/imagen_6.png)

### 7. 正常终止 (`kill`)

我们使用 `kill %1` 命令（或相应的任务编号）终止进程，并使用 `jobs` 进行验证。

![图片 7](img/imagen_7.png)

### 8. 按 PID 终止

我们再次启动进程，这次我们使用其特定的 **PID** "杀死" 它：`kill <PID>`。

![图片 8](img/imagen_8.png)

### 9. 挂起进程 (`CTRL+Z`)

我们在前台启动进程并使用 `CTRL+Z` 暂停/挂起它。

![图片 9](img/imagen_9.png)

### 10. 验证挂起

我们使用 `jobs` 检查状态是否为 "Stopped"（已停止）。

![图片 10](img/imagen_10.png)

### 11. 在前台恢复 (`fg`)

我们使用 `fg` 命令将挂起的任务带到前台。

![图片 11](img/imagen_11.png)

### 12. 进程优先级 (`nice`/`renice`)

要以较低优先级运行进程（较高的 nice 值，例如 10），我们使用 `nice`。要在执行期间更改它，使用 `renice`。

- _注意：`-10` 通常需要 root 权限来提高优先级。_

![图片 12](img/imagen_12.png)

### 13. 再次挂起

我们使用 `CTRL+Z` 暂时停止执行。

![图片 13](img/imagen_13.png)

### 14. 在后台恢复 (`bg`)

我们重新激活进程，但使用 `bg` 将其保持在后台。

![图片 14](img/imagen_14.png)

### 15. 多进程管理

我们重复管理（挂起、`bg`、`fg`），使用像 `sleep 1000` 这样的命令来拥有几个简单的进程。

![图片 15](img/imagen_15.png)

### 16. 复杂演示

至少有 5 个同时进程的场景：挂起、恢复并向其中几个发送信号。

![图片 16](img/imagen_16.png)

### 17. 交互式可视化 (`top` / `htop`)

使用交互式工具实时查看资源消耗。

![图片 17](img/imagen_17.png)

### 18. `ps` 命令及其变体

使用具有各种不同组合的 `ps` 命令来过滤和格式化输出：

??? "ps 命令"

    **示例：**

    1.  `ps`
    2.  `ps aux`
    3.  `ps -ef`
    4.  `ps -ejH`
    5.  `ps -t`
    6.  `ps -ax --forest`
    7.  `ps -e -o`
    8.  `ps -eo`

![图片 18](img/imagen_18.png)

### 19. `pstree` 命令

进程树可视化，用于了解父子层次结构。

![图片 19](img/imagen_19.png)
![图片 19](img/imagen_19_1.png)
![图片 19](img/imagen_19_2.png)

### 20. 子进程和终端 (`gnome-calculator`)

从终端启动 `gnome-calculator` 并关闭终端时，计算器也会关闭。

- **原因**：计算器是 shell 的子进程；当父进程死亡时，子进程也会死亡 (SIGHUP)。

![图片 20](img/imagen_20.png)

### 21. 使用 `nohup`

运行 `nohup gnome-calculator`。关闭终端时，计算器 **保持打开**。

- **原因**：`nohup` 忽略挂起信号 (HUP)。

![图片 21](img/imagen_21.png)

### 22. 完全独立

使用 `nohup`，关闭应用程序（计算器）不会影响终端，关闭终端也不会影响应用程序。它们是独立的。

### 23. `nohup` 输出重定向

为了避免默认的 `nohup.out` 文件并丢弃输出：
`nohup gnome-calculator > /dev/null 2>&1 &`
这会将标准输出和错误都重定向到“空”。

![图片 23](img/imagen_23.png)
